\documentclass[12pt]{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage{caption}
\usepackage{array}
\usepackage{pbox}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{amsmath}
\usepackage{hyperref}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\title{Dokumentacja projektowa}
\date{2018-03-18}
\author{Jędrzej Kozal}

\begin{document}
\bibliographystyle{plabbrv}

\begin{titlepage}
	\centering
	\includegraphics[width=0.25\textwidth]{logo_pol_wroclaw.png}\par\vspace{1cm}
	{\scshape\LARGE Politechnika Wrocławska \par}
	\vspace{1cm}
	{\scshape\Large Wybrane zagadnienia projektowania obiektowego\par}
	\vspace{1.5cm}
	{\huge\bfseries Platforma testowa dla algorytmów uczenia nadzorowanego \par}
	\vspace{2cm}
	{\Large\itshape Filip Guzy\par}
	{\Large\itshape Jędrzej Kozal\par}
	{\Large\itshape Marcin Łokietko\par}

	\vfill
	prowadzący\par
	Dr inż.~Jacek \textsc{Cichosz}

	\vfill

% Bottom of the page
	{\large \today\par}
\end{titlepage}

\tableofcontents
\newpage


\section{Streszczenie}
%Streszczenie, w którym określamy cel projektu. Na przykład, obiektowy model topologii sieci komputerowej może służyć do wizualizacji rozmieszczenia jej węzłów, planowania routingu, itd. Staramy się umieścić nasz system w pewnej ogólnej klasie, np. typu klient–serwer, z bazą danych, sterowany zdarzeniowo, czasu rzeczywistego lub inny. Czy nasz system jest samodzielną aplikacją, fragmentem biblioteki klas, zrębu (ang. framework), komponentu, itp.? 
%Jakie techniki zostały zastosowane (rodzaje dziedziczenia, składania, wymienić zastosowane wzorce projektowe). Wymienić sugerowane języki implementacji, środowiska i proponowane narzędzia. Streszczenie powinno być krótkie (punkty, hasła).


Platforma testowa dla algorytmów uczenia maszynowego jest frameworkiem mającym umożliwiać przeprowadzanie eksperymentów w elastyczny i prosty sposób. W założeniu framework ma pozwalać na skonfigurowanie eksperymentu oraz zebranie wszystkich wyników potrzebnych do określenie skuteczności algorytmu, wygenerowania dokumentacji i zapisu przebiegu. Konstrukcja frameworka ma pozwalać na łatwą integrację w środowisku Continuous Integration.

W trakcie projektowania systemu uwzględniono wysokopoziomowy opis całej aplikacji z podziałem na komponenty oraz niskopoziomowy opis z wyszczególnieniem klas i ich odpowiedzialności.

Wykorzystane wzorce projektowe to:

\begin{itemize}
	\item Budowniczy,
	\item Adapter,
	\item Strategia,
	\item Kompozyt,
	\item Polecenie,
	\item Mediator.
\end{itemize}

W trakcie prac nad projektem rozważano szereg popularnych języków wspierających obiektowy paradygmat programowania tj. Java, C++, Python lub C\#. W dalszej części pracy zawarto szczegółowe rozważania odnośnie języka implementacji.

Dopisać wykorzystane narzędzia.


\section{Wstępny opis słowny}
% 2. Wstępny opis słowny dotyczy tego co system robi, a nie jak. Jest to wyjściowy model werbalny działania systemu, może być on wynikiem wywiadu z potencjalnymi użytkownikami. Zwracamy uwagę na ważne pojęcia, które pojawiły się w opisie, staramy się je ściślej zdefiniować i usystematyzować. Pojęcia te (głównie rzeczowniki) można przedstawić w formie słownika (glosariusza).

Celem zaprojektowanego systemu jest badanie skuteczności wybranych algorytmów \textbf{uczenia nadzorowanego} - rodziny metod należących do dziedziny \textbf{uczenia maszynowego}.
Framework wspiera zarówno \textbf{metody klasyfikacji}, jak i \textbf{regresji}. Jakość analizowanych metod określana jest za pomocą wybranych przez użytkownika \textbf{miar}. W zależności od konfiguracji eksperymentu badania przeprowadzane są z wykorzystaniem \textbf{walidacji krzyżowej} o wybranych parametrach lub klasycznej metody \textbf{holdout}.

Testy wykonywane są na sparametryzowanej przez użytkownika \textbf{bazie danych}, która może podlegać przeprowadzanej przez framework analizie, obejmującej na przykład wykrywanie jej niezbalansowania.

Aplikacja umożliwia porównanie algorytmów na drodze \textbf{statystyczna analiza wyników}.
Wszystkie wyniki eksperymentów reprezentowane są w graficznej postaci.


\section{Słownik pojęć z dziedziny problemu}
%3. Słownik pojęć z dziedziny problemu ułatwia systematykę pojęć z dziedziny problemu, który rozwiązujemy. Przedstawia wyłowione z opisu słownego określenia, które przełożą się następnie na składniki oprogramowania takie jak np. klasy. Zdarza się, że do reprezentacji niektórych pojęć potrzeba kilku klas. Często w systemie pojawią się także klasy nie odpowiadające bezpośrednio terminom w słowniku, a dotyczące dziedziny implementacji.

\begin{itemize}
	\item 
	\textbf{Uczenie nadzorowane} -- zadanie \textbf{uczenia maszynowego}, w którym dane uczące zawierają wektory wejściowe algorytmu wraz z jego oczekiwanym wyjściem. [BISHOP]
	
	\item 
	\textbf{Uczenie maszynowe} -- dziedzina, której celem jest optymalizacja parametrów algorytmu na podstawie posiadanych danych. Ocena jakości algorytmów dokonywana jest z wykorzystaniem przyjętej funkcji strat.
	[ALPAYDIN]
	
	\item 
	\textbf{Algorytm klasyfikacji} -- 
	
	\item 
	\textbf{Algorytm regresji} -- 
	
	\item 
	\textbf{Miara jakości algorytmu} -- 
	% miary jakości: accuracy, precision, recall, ROC, F1-score, G-mean
	
	\item 
	\textbf{Walidacja krzyżowa} -- 
	
	\item 
	\textbf{Holdout} -- 

	\item 
	\textbf{Baza danych} -- 
		
	\item 
	\textbf{Statystyczna analiza wyników} -- 
	
\end{itemize}







\section{Analiza wymagań użytkownika}
%4. Analiza wymagań użytkownika, w której można zastosować poznane w ramach przedmiotu ”inżynieria oprogramowania” przypadki użycia (ang. use case). Ważne jest zrozumienie jak system jest widziany z punktu widzenia użytkownika. Można przedstawić w tym punkcie główny scenariusz działania oraz najciekawsze scenariusze poboczne (czyli tzw. nietypowe sytuacje).

\section{Modele systemu z różnych perspektyw}
%5. Modele systemu z różnych perspektyw to najważniejsza część projektu, w której posiłkujemy się językiem UML do przedstawienia struktury i zachowania naszego systemu. Podstawowym diagramem do opisu struktury jest diagram klas, natomiast zachowanie systemu można zobrazować diagramem sekwencji. W razie potrzeby wykonujemy inne rysunki wyjaśniające nasze idee i koncepcje. Nie boimy się przedstawiać alternatywnych rozwiązań jakiegoś problemu i analizować konsekwencje. Rysunkom muszą towarzyszyć słowne komentarze i wyjaśnienia, dopiero te dwa elementy (grafika + tekst) ułatwiają zrozumienie intencji autora. Wszelkie decyzje projektowe powinny być uzasadnione. Właściwe projektowanie można zacząć od naszkicowania współpracy obiektów w celu realizacji scenariuszy działania systemu opisanych na etapie analizy. W dalszej kolejności przypisujemy obiekty do poszczególnych klas. Wtedy często może się okazać, że potrzebnych jest więcej klas niż założyliśmy wstępnie. Należy zwrócić uwagę aby modele systemu z różnych perspektyw były spójne.

\section{Kwestie implementacyjne}
%6. Kwestie implementacyjne Na tym etapie zastanawiamy nad wyborem języków implementacji, środowisk i narzędzi.

Obecnie istnieje wiele popularnych obiektowych języków programowania. W niniejszej sekcji pracy przeprowadzono dyskusję możliwych języków implementacji.

\paragraph{Python}
Python jest językiem typowanym dynamicznie, kompilowanym do kodu bajtowego maszyny wirtualnej. Zyskał dużą popularność przez prostotę składni, przystępność oraz dużą liczbę dostępnych bibliotek. W konteście realizowanego projektu Python może być wskazanym językiem ze względu na dużą dostępność narzędzi i bibliotek przeznaczonych do uczenia maszynowego. W teorii Python wspiera obiektowość, jednakże pewne mechanizmy związane z dynamicznym typowaniem uniemożliwiają pełne wykorzystanie zasad paradygmatu obiektowego. Przykładowo Python udostępnia możliwosć tworzenia interfesjów z wykorzystaniem AbstractBaseClass (ABC). W ABC można zdefiniować metody interfejsu, które muszą być zaimplementowane w klasach dziedziczących po ABC. Brak implementacji skutkuje pojawieniem się wyjątku. Trudno jest zaimplementować zachowania polimorficzne, ze względu na ducktyping. Dodatkowo mechanizm enkapsulacji w tym języku nie istnieje. Jest on symulowany przez name mangling - mechanizm zamiany przez interpreter nazw metod z podwójnym podkreślinikiem na początku nazwy. Istnieją pewne zaawansowane mechanizmy takie jak metaklasy pozwalające na stosowanie refleksji oraz elementy paradygmatu funkcyjnego, które mają wpływ na sposób implementacji w Pythonie, jednakże są mało istotne w kontekście omawianego projektu.

\paragraph{C++}
C++ jest językiem ogólnego przeznaczenia wspierającym wiele paradygmatów. Jego główną zaletą jest szybkość kodu, wynikająca głównie z kompilacji do kodu maszynowego. C++ jest silnie typowany, przez co wiele błędów można wykryć na etapie kompilacji kodu. Niewątpliwą zaletą tego języka jest rozbudowany system szablonów, który pozwala na wykorzystanie zaawansowanych technik metaprogramowania. W \cite{Cpp_turing_complete} wykazano, że szablony C++ są kompletne w sensie Turinga. Oznacza to, że można w nich zaimplementować dowolny algorytm z klasy obliczeniowej rozwiązywalnej na maszynie Turinga. Ciekawym projektem jest \cite{Cpp_snake_compile_time} gdzie zaimplementowano popularną grę Snake z wykorzystaniem szablonów. Polecenia ruchu są zadawane w czasie kompilacji i jednocześnie w trakcie kompilacji są dokonywane wszystkie obliczenia. Restrykcyjność języka może być powodem wolniejszego tempa implementacji w C++. Dodatkowo operacje na zasobach są jedną z najbardziej niebezpiecznych aspektów tego języka. C++ nie posiada garbage collectora, przez co na programiście ciąży obowiązek zwalniania zaalokowanych zasobów. Istnieją w C++ mechanizmy umożliwiające bezpieczne zarządzanie zasobami, jednakże ich stosowanie wymaga dużego nakładu dyscypliny (przykładowo według Scotta Mayersa najważniejszym wynalazkiem języka jest destruktor, który umożliwił pojawienie się idiomu RAII). Pojawienie się nowszych standardów znacząco poprawiło wygodę programistów i bezpieczeństwo operowania na zasobach, przez np. dodanie inteligentnych wskaźników.

\paragraph{Java}
Java to język w pełni obiektowy, kompilowany do kodu bajtowego. Pełna obiektowość języka oznacza konieczność przynależności zmiennych i funkcji do klas. Nie jest możliwe zadeklarowanie osobnych zmiennych jak to jest możliwe np. w C++. Maszyna wirtualna Javy posiada wiele mechanizmów pozwalających na zwiększenie efektywności programów, takich jak JIT compiler, przez co Java zyskała na popularności w aplikacjach działających po stronie serwera. Dodatkowo wykorzystanie grabage collectora pozwala zmniejsza odpowiedzialność programisty, co przyczynia się do zwiększenia popularności języka.

\paragraph{C\#}
C\# jest podobnie jak Java językiem czysto obiektowym kompilownym w pierwszym etapie do kodu pośredniego (IL - intermediate language), a następnie do kodu maszynowego za pomocą kompilatora JIT. C\# jest oparty na frameworku .NET.

\section{Podsumowanie i dyskusja krytyczna}
%7. Podsumowanie i dyskusja krytyczna Tu zamieszczamy spostrzeżenia na temat wykorzystania w projekcie ciekawych technik i co dzięki nim zyskaliśmy.

\section{Wykaz materiałów źródłowych}
%8. Wykaz materiałów źródłowych Podajemy źródła, z których korzystaliśmy (książki, artykuły, strony internetowe)

\bibliography{bibliography}

\listoffigures


\end{document}